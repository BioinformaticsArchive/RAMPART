RAMPART README

Version: 0.4.1
Date: 8th July 2013


What does RAMPART do?
=====================

RAMPART is an automated de novo assembly pipeline.  The pipeline can be divided into a number of steps:

1 - Create a quality trimmed version of the raw input allLibraries.
2 - Perform a kmer optimisation procedure where multiple contig assemblies are execute with a range of kmer values.  
The best assembly is selected for the next stage.
3 - Enhance the best contig assembly using scaffolding, gap closing and other post-processing features.
4 - Reporting job information.


Installation
============

Download the RAMPART jar from  to a directory of your choice.  The jar is a "shaded" jar which means that it contains all
required dependencies, except for the java JRE.  JRE 1.6 or above is required to run RAMPART.  Optionally, add this
directory containing the jar to your PATH environment variable for convienience.

RAMPART uses a number of 3rd party tools during processing.  The current list is described below.  For full functionality,
all these tools should be installed on your environment, however some of the tools are mandatory whereas others are optional.

Mandatory dependencies:
- JRE v1.6 or above
- R V2 or above

At least one of:
- MASS: Abyss V1.3; SOAPdenovo V2

Optional:
- MECQ: Sickle V1.1; Quake V0.3; Musket V1.0
- AMP: SSPACE Basic V2.0; SOAP GapCloser V1.12



Supported Platforms
===================

RAMPART is a command line application written in java, so in theory is portable to any system running the Java Runtime
Environment (JRE) 1.6 and above.  However, RAMPART does depend on a number of tools to do read error correction, de novo
assembly, and assembly improvement and most of these tools are linux specific.  Tools such as cygwin on windows and MacPorts
may help here, although no guarentees are made.  In addition, RAMPART is designed to exploit High Performance Computing
(HPC) architectures, and to use Scheduling systems that these architecture often employ.  In particular, Platform Load
Sharing Facility (LSF) is supported, often these scheduling systems only run on a unix platform.



Quick Start
===========

1. Create a job configuration file (details below) in a clean directory.
2. Then make this directory the working directory and type: "java -jar rampart-0.4.jar --config <name of config file>"

This will run RAMPART with its default settings on the data you've provided in the config file.  Details on how to
construct a config file are described in the next section.

More information on RAMPART usage can be obtained by typing "java -jar rampart-0.4.jar --help".



Job Config File
===============

An example configuration file can be found in "<rampart dir>/example.cfg".  The configuration file takes a standard "ini"
format and is divided into the following sections:

- [JOB] - which contains all general information regarding the job to be run.  These properties are not actually used by
the system at present, although in the future they may be used to construct a job report.  For now they just help to
describe and identify this configuration file.  It is not a requirement to complete these properties.

- [LIB<x>] - which represents a library that should be processed by RAMPART.  The <x> represents the order in which this
library should be processed.  Generally, we start with [LIB1] and increment this value as necessary.

- [MECQ] - which contains properties for the Quality Trimming stage.

- [MASS] - which contains properties for the Multiple Assembly stage.  Typically use this to set kmer range.

- [AMP] - which contains properties for the Improver stage.  Typically use this to set the tool order.

Each section can contain properties, which take the following format: "<key>=<value>".  Each property should be separated
by a new line.

The JOB section can contain the following properties :

- "author"        - The author of the job / report
- "collaborator"  - Any partner who is involved with this job.
- "institution"   - The institution for whom the collaborator works.
- "title"         - The title of this job


Each LIB section can contain the following properties:

- "name"                 - The library name, for use in the report.
- "read_length"          - The maximum read length for reads in this library
- "avg_insert_size"      - The average insert size for paired end or mate pair reads
- "insert_err_tolerance" - Used in the scaffolding step to determine how tolerant the scaffolder should be when mapping
reads that deviate
from the expected insert_size
- "usage"                - One or more of the following values separated by commas: "QT", "ASM", "SCF, "GC", or all.
e.g. "usage=QT,ASM,SCF"
- "seq_orientation"      - One of the following values: "FR", "RF", "FF", "RR" (generally FR for paired end and RF for
mate pair).
- "type"                 - Library type: "SE", "PE", or "MP"
- "file_paired_1"        - If this is a paired end or mate pair library, this represents the first file of the pair.
- "file_paired_2"        - If this is a paired end of mate pair library, this represents the second file of the pair.
- "se_file"              - For use if this is a single end read library.

The MASS section can contain the following properties:

- "tool"        - The tool and version to use for assembling
- "threads"     - The number of threads to use for assembling
- "memory"      - The approximate amount of memory required to assemble the job (used for job scheduling)
- "parallel"    - The level of parallelism to use: PARALLEL_ASSEMBLIES_ONLY
- "kmin"		- The minimum kmer value to process (don't pick even numbers, preferably pick a number which has a unit
digit of 1, i.e. 41)
- "kmax"		- The maximum kmer value to process (don't pick even numbers, preferably pick a number which has a unit
digit of 1 or 5, i.e. 91 or 95)

The AMP section can contain the following properties:

- <INDEX NUM>	- This key should be a number describing the position in the queue in an assembly enhancement tool should
be run.  Available assembly enhancement tools include: SCAFFOLD, DEGAP, DEDUP, CLIP.  This will use the default tools for
each class if no tool name is specified.  To specify a particular tool add the tool name after a space.  For example:

   1=SCAFFOLD SSPACE
   2=DEGAP             (uses default degapping tool)




RAMPART Environment Configuration
=================================

It is expected that a file called "conan.properties" exists in "~/.tgac/rampart/"   In this file it is possible to describe
the execution context within which to run the RAMPART pipeline.  For example, you can specify the scheduling system to use and
if so, what queue to run on.  Known properties:

executionContext.scheduler          - Valid options {LSF}
executionContext.scheduler.queue    - Depends on Scheduling setup
executionContext.locality = LOCAL   - Always use this!

In addition, RAMPART uses SLF4J as a logging facade and is currently configured to use LOG4J.  If you which to alter to
logging configuration then modify the "log4j.properties" file.  For details please consult:
"http://logging.apache.org/log4j/2.x/"

Often it's not possible to keep all these tools with the specified versions on the PATH.  It is possible to specify
another file in the "conan.properties" file using the "externalProcessConfigFile" property.  This file can contain any
commands that should be executed before running each process.  This enables the user to execute any commands that would
bring the specified tools onto the PATH for the given environment.  Currently known process keys are as follows:

R_V2.12.2
jre-6
Sickle_V1.1
Abyss_V1.3.4
SSPACE_Basic_v2.0
SOAP_GapCloser_v1.12
SoapDeNovo_V2.04
Quake_V0.3.4
Musket_V1.0.6

Format: <key>=<command to bring tool onto PATH>



Output
======

A typical RAMPART run will produce the following directory structure:

- /reads    - A directory containing quality trimmed versions of the input allLibraries and custom configuration files
representing both the raw and quality trimmed datasets.
- /mass     - A directory containing the results of assembling the raw and qt trimmed input allLibraries.
- /amp - A directory containing the results of the assembly enhancement process applied to the best contig assembly
from MASS.
- /report   - A directory containing an automatically generated report detailing the results of this RAMPART job.



Extending the Software / Compilation
====================================

RAMPART is a java / maven project that depends on two other java / maven projects: TgacConanProcs and ConanX.  Both of
these projects are available from github. The projects require JDK 1.6 or above to compile.  It should be possible to
load the maven poms from each project into any maven aware IDE (IntelliJ Idea, Net Beans, Eclipse).  The exact steps to
create the projects locally on your machine are as follows:

1. Ensure GIT, Maven and JDK v1.6+ is installed
2. Open a terminal
3. Create directory for ConanX
4. Change into new ConanX directory
5. Type: "git clone https://github.com/tburdett/Conan2.git -b conanx"
6. Type: "cd Conan2"
6. Type: "mvn clean install"
6. Create a directory for TgacConanProcs (not in ConanX directory)
7. Change into new TgacConanProcs directory
8. Type: "https://github.com/TGAC/TgacConanProcs.git"
9. Type: "mvn clean install"
10. Create a directory for RAMPART (not in TgacConanProcs directory)
11. Change into new RAMPART directory
12. Type: "https://github.com/TGAC/RAMPART.git"
13. Type: "mvn clean install"

The final RAMPART jar containing Conan and TGACConanProcs can be found in <rampart_dir>/target/rampart-<version>.jar.


License
=======

RAMPART and TgacConanProcs are available under GNU GLP V3.  Conan is available under GNU Lesser GPL V2.  For licensing
details of other RAMPART dependencies please consult their documentation.


Contact
=======

Daniel Mapleson (TGAC)
http://tgac.ac.uk/
daniel.mapleson@tgac.ac.uk
