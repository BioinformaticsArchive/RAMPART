#!/usr/bin/perl

use strict;
use warnings;

# 3rd Part modules
use Getopt::Long;
use Pod::Usage;
use File::Find;
use Cwd;
use Cwd 'abs_path';
use File::Basename;

my ( $RAMPART, $RAMPART_DIR ) = fileparse( abs_path($0) );

# Sequence info path
my $SEQ_INFO_PATH = $RAMPART_DIR  . "tools/sequence_info";
my $MASS_FORMATTER_PATH = $RAMPART_DIR  . "mass_formatter.pl";

# Other constants
my $PWD = getcwd;

# Assign any command line options to variables
my (%opt) = ( );

GetOptions( 
	\%opt, 
	'index',
	'verbose|v',
	'help|usage|h|?',
	'man' )
  or pod2usage("Try '$0 --help' for more information.");

# Display usage message or manual information if required
pod2usage( -verbose => 1 ) if $opt{help};
pod2usage( -verbose => 2 ) if $opt{man};

# Get input directory
my @in_dir = @ARGV;
my $input_dir = join " ", @in_dir;

print "\n"                                  if $opt{verbose};
print "Command line arguments gathered\n\n" if $opt{verbose};

# Argument Validation

die "Error: No input files specified\n\n" unless @in_dir;
die "Error: Can only analyse one assembly group at a time\n\n"
  unless ( @in_dir == 1 );
die "Error: Input directory does not exist: " . $input_dir . "\n\n"
  unless ( -e $input_dir );

print "Validated arguments\n\n" if $opt{verbose};
print "Input directory: " . $input_dir . "\n" if $opt{verbose};
if ( $opt{verbose} ) {
	print "Options:\n";
	foreach ( keys %opt ) {
		print "\t'$_' => " . $opt{$_} . "\n";
	}
	print "\n";
}

# Find all appropriate files in input directory

my @assemblies;

sub wanted { push @assemblies, $File::Find::name }
find( \&wanted, $input_dir );
my @scaffolded_assemblies = grep( /-scaffolds.fa$/, @assemblies );
my @contiged_assemblies = grep( /-contigs.fa$/, @assemblies );

my @filtered_assemblies = (@contiged_assemblies, @scaffolded_assemblies);
my @sorted_assemblies = sort(@filtered_assemblies);

if ( $opt{verbose} ) {
	print "Found these files in the input directory:\n"
	  . ( join "\n", @sorted_assemblies ) . "\n\n" . "\n\n";
}

# Run sequence_info on each and pipe into tabulateor
my @table;
my $i = 1;
foreach (@sorted_assemblies) {
	my ( $name, $dir ) = fileparse( abs_path($0) );
	my $tabulate_cmd =
	    $SEQ_INFO_PATH
	  . " -n -r "
	  . $_ . " | "
	  . $MASS_FORMATTER_PATH 
	  . " --notitle";
	my $output   = `$tabulate_cmd`;
	
	if($output =~ m/^\|\|\|/i) {
		#print "Warning: " . $name . " does not contain any assembly information.";
	}
	else {
		if ($opt{index}) {
			print "index-" . $i . "\n" if $opt{verbose};
			print $output . "\n"  if $opt{verbose};
			push @table, $i . "|" . $output;
		}
		else {
			my $matchstr = $output;
			$matchstr =~ m/k(\d+)-/;
			print "k" . $1 . "\n" if $opt{verbose};
			print $output . "\n"  if $opt{verbose};
			push @table, $1 . "|" . $output;
		}
	}
	 
	$i++;
}

# Need to do some extra sorting here to numerically order by kmer size
my @s_table = sort {
	my @name_pair = map { /^(\d+)(\|.*)/; $1 } ( $a, $b );
	$name_pair[0] <=> $name_pair[1];
} @table;


print "\nStatistics:\n" if $opt{verbose};
my $col1 = $opt{index} ? "index" : "kmer";
print $col1 . "|file|nbcontigs|a.pc|c.pc|g.pc|t.pc|n.pc|total|minlen|maxlen|avglen|n50\n"
  . ( join "", @s_table ) . "\n";

sub which {

	# Get the passed value
	my $program = shift;

	# Return if nothing is provided
	return if ( not defined($program) );

	# Load the path
	my $path = $ENV{PATH};

	# Let's replace all \ by /
	$path =~ s/\\/\//g;

	# Substitute all /; by ; as there could be some trailing / in the path
	$path =~ s/\/;/;/g;

	# Now make an array
	my @path = split( /;/, $path );

	# Loop and find if the file is in one of the paths
	foreach (@path) {

		# Concatenate the file
		my $file = $_ . '/' . $program;

		# Return the path if it was found
		return $file if ( ( -e $file ) && ( -f $file ) );
	}
}

__END__

=pod

=head1 NAME

B<mass_gatherer.pl>


=head1 SYNOPSIS

B<mass_gatherer.pl> [options] F<input_directory>

For full documentation type: "mass_gatherer.pl --man"


=head1 DESCRIPTION

Multiple Assembly Statistics Gatherer.  Assesses a group of assemblies and produces a table of assembly statistics.


=head1 OPTIONS

=over

=item B<--index>

Prefix each line of output with the index of each scaffold file.  This is intended to be used instead of the kmer values which would be generated by mass.  Useful for the improver tool.

=item B<--verbose>,B<-v>

Print extra status information during run.

=item B<--help>,B<--usage>,B<-h>,B<-?>

Print usage message and then exit.

=item B<--man>

Display manual.

=back

=head1 AUTHORS

Daniel Mapleson <daniel.mapleson@tgac.ac.uk>

Nizar Drou <nizar.drou@tgac.ac.uk>

=cut

_
